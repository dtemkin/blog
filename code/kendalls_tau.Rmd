---
title: "KendallsTau"
author: "Dan"
date: "March 8, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Setup

```{r data}
set.seed(1221212)
data.example.1 <- data.frame(restaurant_ranks_bill=runif(20, 1, 5), restaurant_ranks_joe=runif(20, 1, 5))
print(data.example.1)

cor.test(x=data.example.1$restaurant_ranks_bill, y=data.example.1$restaurant_ranks_joe, method='kendall')


```

## Global Object
```{r globals}

# number of concordant pairs

PairwiseConcordDiscord <-function(x){

  pi.c <- pi.d <- pi.t <- matrix(0, nrow = nrow(x), ncol = ncol(x))
  
  row.x <- row(x)
  col.x <- col(x)

  for(i in 1:n){
    for(j in 1:m){
      pi.c[i, j] <- sum(x[row.x<i & col.x<j]) + sum(x[row.x>i & col.x>j])
      pi.d[i, j] <- sum(x[row.x<i & col.x>j]) + sum(x[row.x>i & col.x<j])
    }
  }
  C <- sum(pi.c * x)/2
  D <- sum(pi.d * x)/2


  return(list(pi.c = pi.c, pi.d = pi.d, concordances = C, discordances = D))

}



```


## Kendall's Tau-a

equal to concordant minus discordant pairs, divided by a factor to account for total number of pairs (sample size).

```{r kendalls_tau_a}

KendallTauA <- function(x, y, dir = c("row", "column"), conf.level = .95, include_pvalue=TRUE, ...){

  tab <- table(x, y, ...)


  x <- PairwiseConcordDiscord(tab)

  n <- sum(tab)
  n0 <- n*(n-1)/2

  taua <- (x$concordances - x$discordances) / n0

  # Hollander, Wolfe pp. 415/416
  # think we should not consider ties here, so take only the !=0 part
  conf.interval <- as.vector((x$pi.c - x$pi.d) * (tab!=0))
  conf.interval <- conf.interval[conf.interval!=0]
  conf.interval_ <- sum(conf.interval)/n
  sigma2 <- 2/(n*(n-1)) * ((2*(n-2))/(n*(n-1)^2) * sum((conf.interval - C_)^2) + 1 - taua^2)

  pvalue <- sig.test.za(nc=length(x$concordances), nd=length(x$discordances), n=n, tails =2)
  pr2 <- 1 - (1 - conf.level)/2
  
  conf.interval <- qnorm(pr2) * sqrt(sigma2) * c(-1, 1) + taua
  if (include_pvalue == TRUE){
    if (pvalue < 1-conf.level){
      p.interp <- "REJECT NULL HYPOTHESIS (Values not statistically independent)"
    } else {
      p.interp <- "FAIL TO REJECT NULL HYPOTHESIS (Values likely independent)"
    }
    result <- c(tau_a = taua, lower.ci = max(conf.interval[1], -1), upper.ci = min(conf.interval[2], 1), pvalue=pvalue, interp=p.interp)
    
  } else{
    result <- c(tau_a = taua, lower.ci = max(conf.interval[1], -1), upper.ci = min(conf.interval[2], 1))
  }


  return(result)
}

sig.test.za <- function(nc, nd, n){
  # not including adjustment for ties
  z <- (3*(nc-nd)) / sqrt((n*(n-1)*(2*n + 5))/2)
  return((-1*abs(z))*2)
}

```

## Kendall's Tau-b

explicit accounting for ties--ie, both members of the data pair have the same value; this value is equal to concordant minus discordant pairs divided by a term representing the geometric mean between the number of pairs not tied on x (X0) and the number not tied on y (Y0).

```{r kendalls_tau_b}


KendallTauB <- function(x, y, conf.level = .95, include_pvalue=TRUE, ...){

  # Reference: http://www.fs.fed.us/psw/publications/lewis/LewisHMP.pdf (pp 2-9)
  

  dname <- deparse(substitute(x))
  tab <- table(x, y)
  

  x <- PairwiseConcordDiscord(tab)

  n <- sum(tab)
  n0 <- n*(n-1)/2
  ti <- rowSums(tab)  # apply(tab, 1, sum)
  tj <- colSums(tab)  # apply(tab, 2, sum)
  n1 <- sum(ti * (ti-1) / 2)
  n2 <- sum(tj * (tj-1) / 2)

  taub <- (x$concordances - x$discordances) / sqrt((n0-n1)*(n0-n2))

  pdiff.1 <- (x$pi.c - x$pi.d) / sum(tab)
  pdiff.2 <- 2 * (x$concordances - x$discordances) / sum(tab)^2

  rowsum <- rowSums((tab / sum(tab)))  # apply(pi, 1, sum)
  colsum <- colSums((tab / sum(tab)))  # apply(pi, 2, sum)

  rowmatrix <- matrix(rep(rowsum, dim(tab)[2]), ncol = dim(tab)[2])
  colmatrix <- matrix(rep(colsum, dim(tab)[1]), nrow = dim(tab)[1], byrow = TRUE)

  delta.1 <- sqrt(1 - sum(rowSums(tab / sum(tab))^2))
  delta.2 <- sqrt(1 - sum(colSums(tab / sum(tab))^2))

  # Compute asymptotic standard errors taub
  tauphi <- (2 * pdiff.1 + pdiff.2 * colmatrix) * delta.2 * delta.1 + (pdiff.2 * rowmatrix * delta.2)/delta.1
  sigma2 <- ((sum((tab / sum(tab)) * tauphi^2) - sum((tab / sum(tab)) * tauphi)^2)/(delta.1 * delta.2)^4) / n

  
  conf.interval <- qnorm(1 - (1 - conf.level)/2) * sqrt(sigma2) * c(-1, 1) + taub
  pvalue <- sig.test.zb(nc=length(x$concordances), nd=length(x$discordances), n=n, ti=ti, tj=tj)
  if (include_pvalue == TRUE){
    if (pvalue < 1-conf.level){
      p.interp <- "REJECT NULL HYPOTHESIS (Values not statistically independent)"
    } else {
      p.interp <- "FAIL TO REJECT NULL HYPOTHESIS (Values likely independent)"
    }
    result <- c(tau_b = taub, lower.ci = max(conf.interval[1], -1), upper.ci = min(conf.interval[2], 1), pvalue=pvalue, interp=p.interp)
  }else{
    result <- c(tau_b = taub, lower.ci = max(conf.interval[1], -1), upper.ci = min(conf.interval[2], 1))
  }
  
  return(result)
}

sig.test.zb <- function(nc, nd, n, ti, tj){
  # based on formula from wikipedia
  v0 <- n*(n-1)*(2*n+5)
  vt <- sum(ti*(ti-1)*(2*ti+5))
  vu <- sum(tj*(tj-1)*(2*tj+5))
  v1 <- sum(ti*(ti-1))*sum(tj*(tj-1)) / (2*n*(n-1))
  v2 <- sum(ti*(ti-1)*(ti-2))*sum(tj*(tj-1)*(tj-2)) / (9*n*(n-1)*(n-2))
  v <- (v0 - vt - vu) / (18 + v1 + v2)
  return((nc-nd)/sqrt(v))
}


```

## Kendall's Tau-c

larger-table variant also optimized for non-square tables; equal to concordant minus discordant pairs multiplied by a factor that adjusts for table size).

```{r kendalls_tau_c}
KendallTauC <- function(x, y, conf.level = .95, ...) {

  tab <- table(x, y, ...)

  # Reference:
  # http://v8doc.sas.com/sashtml/stat/chap28/sect18.htm
  x <- PairwiseConcordDiscord(tab)

  m <- min(dim(tab))
  n <- sum(tab)
  # Asymptotic standard error: sqrt(sigma2)
  sigma2 <- 4 * m^2 / ((m-1)^2 * n^4) * (sum(tab * (x$pi.c - x$pi.d)^2) - 4 * (x$concordances -x$discordances)^2/n)
  # debug: print(sqrt(sigma2))

  # Tau-c = (C - D)*[2m/(n2(m-1))]
  tauc <- (x$concordances - x$discordances) * 2 * min(dim(tab)) / (sum(tab)^2*(min(dim(tab))-1))
  
  conf <- sig.test.c(sigsq=sigma2, tauc = tauc)
  result <- c(tauc = tauc,  lower.ci=max(conf[1], -1),
              upper.ci=min(conf[2], 1))
  return(result)
}


sig.test.c <- function(sigsq, tauc, conf.level=.95){
  prob <- 1 - (1 - conf.level)/2
  conf.interval <- qnorm(prob) * sqrt(sigsq) * c(-1, 1) + tauc
  return(c(conf.interval[2], conf.interval[1]))
}



```

